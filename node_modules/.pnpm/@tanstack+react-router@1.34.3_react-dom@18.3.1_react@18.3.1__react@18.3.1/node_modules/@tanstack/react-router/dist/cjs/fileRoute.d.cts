import { ParsePathParams } from './link.cjs';
import { AnyContext, AnyPathParams, AnyRoute, AnySearchSchema, FileBaseRouteOptions, ResolveAllContext, ResolveAllParamsFromParent, ResolveFullSearchSchema, ResolveFullSearchSchemaInput, ResolveLoaderData, ResolveRouteContext, ResolveSearchSchemaUsed, Route, RouteConstraints, RouteContext, RouteLoaderFn, UpdatableRouteOptions } from './route.cjs';
import { Assign, IsAny } from './utils.cjs';
import { MakeRouteMatch } from './Matches.cjs';
import { NoInfer } from '@tanstack/react-store';
import { RegisteredRouter } from './router.cjs';
import { RouteById, RouteIds } from './routeInfo.cjs';

export interface FileRoutesByPath {
}
export declare function createFileRoute<TFilePath extends keyof FileRoutesByPath, TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'], TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'], TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'], TFullPath extends RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath']>(path: TFilePath): <TSearchSchemaInput = {}, TSearchSchema = {}, TSearchSchemaUsed = ResolveSearchSchemaUsed<TSearchSchemaInput, TSearchSchema>, TFullSearchSchemaInput = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>, TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams = Record<ParsePathParams<TPath, never>, string>, TAllParams = ResolveAllParamsFromParent<TParentRoute, TParams>, TRouteContextReturn = RouteContext, TRouteContext = ResolveRouteContext<TRouteContextReturn>, TAllContext = Assign<IsAny<TParentRoute["types"]["allContext"], {}, TParentRoute["types"]["allContext"]>, TRouteContext>, TRouterContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = unknown, TLoaderData = ResolveLoaderData<TLoaderDataReturn>, TChildren = unknown>(options?: (FileBaseRouteOptions<TParentRoute, TPath, TSearchSchemaInput, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & {
    caseSensitive?: boolean | undefined;
    wrapInSuspense?: boolean | undefined;
    component?: import('./route').RouteComponent<any> | undefined;
    errorComponent?: false | import('./route').ErrorRouteComponent | null | undefined;
    notFoundComponent?: import('./route').NotFoundRouteComponent | undefined;
    pendingComponent?: import('./route').RouteComponent<any> | undefined;
    pendingMs?: number | undefined;
    pendingMinMs?: number | undefined;
    staleTime?: number | undefined;
    gcTime?: number | undefined;
    preloadStaleTime?: number | undefined;
    preloadGcTime?: number | undefined;
    preSearchFilters?: import('./route').SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
    postSearchFilters?: import('./route').SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
    onCatch?: ((error: Error, errorInfo: import('react').ErrorInfo) => void) | undefined;
    onError?: ((err: any) => void) | undefined;
    onEnter?: ((match: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void) | undefined;
    onStay?: ((match: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void) | undefined;
    onLeave?: ((match: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => void) | undefined;
    meta?: ((ctx: {
        matches: import('./Matches').RouteMatch<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>[];
        params: TAllParams;
        loaderData: TLoaderData;
    }) => import('react').DetailedHTMLProps<import('react').MetaHTMLAttributes<HTMLMetaElement>, HTMLMetaElement>[]) | undefined;
    links?: (() => import('react').DetailedHTMLProps<import('react').LinkHTMLAttributes<HTMLLinkElement>, HTMLLinkElement>[]) | undefined;
    scripts?: (() => import('react').DetailedHTMLProps<import('react').ScriptHTMLAttributes<HTMLScriptElement>, HTMLScriptElement>[]) | undefined;
    headers?: ((ctx: {
        loaderData: TLoaderData;
    }) => Record<string, string>) | undefined;
} & {
    staticData?: import('./route').StaticDataRouteOption | undefined;
}) | undefined) => Route<TParentRoute, TPath, TFullPath, TFilePath, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren>;
/**
  @deprecated It's no longer recommended to use the `FileRoute` class directly.
  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.
*/
export declare class FileRoute<TFilePath extends keyof FileRoutesByPath, TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'], TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'], TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'], TFullPath extends RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath']> {
    path: TFilePath;
    silent?: boolean;
    constructor(path: TFilePath, _opts?: {
        silent: boolean;
    });
    createRoute: <TSearchSchemaInput = {}, TSearchSchema = {}, TSearchSchemaUsed = ResolveSearchSchemaUsed<TSearchSchemaInput, TSearchSchema>, TFullSearchSchemaInput = ResolveFullSearchSchemaInput<TParentRoute, TSearchSchemaUsed>, TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams = Record<ParsePathParams<TPath>, string>, TAllParams = ResolveAllParamsFromParent<TParentRoute, TParams>, TRouteContextReturn = RouteContext, TRouteContext = ResolveRouteContext<TRouteContextReturn>, TAllContext = ResolveAllContext<TParentRoute, TRouteContext>, TRouterContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderDataReturn = unknown, TLoaderData = ResolveLoaderData<TLoaderDataReturn>, TChildren = unknown>(options?: FileBaseRouteOptions<TParentRoute, TPath, TSearchSchemaInput, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TRouterContext, TAllContext, TLoaderDeps, TLoaderDataReturn> & UpdatableRouteOptions<TId, TAllParams, TFullSearchSchema, TLoaderData, TAllContext, TRouteContext, TLoaderDeps>) => Route<TParentRoute, TPath, TFullPath, TFilePath, TId, TSearchSchemaInput, TSearchSchema, TSearchSchemaUsed, TFullSearchSchemaInput, TFullSearchSchema, TParams, TAllParams, TRouteContextReturn, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderDataReturn, TLoaderData, TChildren>;
}
/**
  @deprecated It's recommended not to split loaders into separate files.
  Instead, place the loader function in the the main route file, inside the
  `createFileRoute('/path/to/file)(options)` options.
*/
export declare function FileRouteLoader<TFilePath extends keyof FileRoutesByPath, TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute']>(_path: TFilePath): <TLoaderData>(loaderFn: RouteLoaderFn<TRoute['types']['allParams'], TRoute['types']['loaderDeps'], TRoute['types']['allContext'], TRoute['types']['routeContext'], TLoaderData>) => RouteLoaderFn<TRoute['types']['allParams'], TRoute['types']['loaderDeps'], TRoute['types']['allContext'], TRoute['types']['routeContext'], NoInfer<TLoaderData>>;
export type LazyRouteOptions = Pick<UpdatableRouteOptions<string, AnyPathParams, AnySearchSchema, {}, AnyContext, AnyContext, {}>, 'component' | 'errorComponent' | 'pendingComponent' | 'notFoundComponent'>;
export declare class LazyRoute<TRoute extends AnyRoute> {
    options: {
        id: string;
    } & LazyRouteOptions;
    constructor(opts: {
        id: string;
    } & LazyRouteOptions);
    useMatch: <TRouteMatch = MakeRouteMatch<any, TRoute["types"]["id"]>, TSelected = TRouteMatch>(opts?: {
        select?: (match: TRouteMatch) => TSelected;
    }) => TSelected;
    useRouteContext: <TSelected = TRoute["types"]["allContext"]>(opts?: {
        select?: (s: TRoute['types']['allContext']) => TSelected;
    }) => TSelected;
    useSearch: <TSelected = TRoute["types"]["fullSearchSchema"]>(opts?: {
        select?: (s: TRoute['types']['fullSearchSchema']) => TSelected;
    }) => TSelected;
    useParams: <TSelected = TRoute["types"]["allParams"]>(opts?: {
        select?: (s: TRoute['types']['allParams']) => TSelected;
    }) => TSelected;
    useLoaderDeps: <TSelected = TRoute["types"]["loaderDeps"]>(opts?: {
        select?: (s: TRoute['types']['loaderDeps']) => TSelected;
    }) => TSelected;
    useLoaderData: <TSelected = TRoute["types"]["loaderData"]>(opts?: {
        select?: (s: TRoute['types']['loaderData']) => TSelected;
    }) => TSelected;
    useNavigate: () => import('./useNavigate').UseNavigateResult<string>;
}
export declare function createLazyRoute<TId extends RouteIds<RegisteredRouter['routeTree']>, TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>>(id: TId): (opts: LazyRouteOptions) => LazyRoute<TRoute>;
export declare function createLazyFileRoute<TFilePath extends keyof FileRoutesByPath, TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute']>(path: TFilePath): (opts: LazyRouteOptions) => LazyRoute<TRoute>;
